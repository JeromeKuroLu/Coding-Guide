<!DOCTYPE html>
<html lang=zh>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    <meta name="description" content="Table of Contents  generated with DocToc

【译文】用ES6写更赞的JavaScript（2）
后退一步：类不是什么
基础：声明&amp;amp;表达式
使用extends创建子类&amp;amp;调用super方法
深入原型
使用构造函数创建对象
体验原型链
给对象设置原型
名为对象的方法
默认规则
通过new隐式设置
通过Object.create显式设置">
<meta property="og:type" content="article">
<meta property="og:title" content="【译文】用ES6写更赞的JavaScript（2）">
<meta property="og:url" content="http://ecmadao.com/2017/01/13/Notes/译文/ES6/【译文】用ES6写更赞的JavaScript（2）/index.html">
<meta property="og:site_name" content="ecmadao">
<meta property="og:description" content="Table of Contents  generated with DocToc

【译文】用ES6写更赞的JavaScript（2）
后退一步：类不是什么
基础：声明&amp;amp;表达式
使用extends创建子类&amp;amp;调用super方法
深入原型
使用构造函数创建对象
体验原型链
给对象设置原型
名为对象的方法
默认规则
通过new隐式设置
通过Object.create显式设置">
<meta property="og:image" content="http://ecmadao.com/Coding-Guide/images/BetterJavaScriptWithES6/ebbd5e3.png">
<meta property="og:updated_time" content="2017-01-14T13:18:58.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="【译文】用ES6写更赞的JavaScript（2）">
<meta name="twitter:description" content="Table of Contents  generated with DocToc

【译文】用ES6写更赞的JavaScript（2）
后退一步：类不是什么
基础：声明&amp;amp;表达式
使用extends创建子类&amp;amp;调用super方法
深入原型
使用构造函数创建对象
体验原型链
给对象设置原型
名为对象的方法
默认规则
通过new隐式设置
通过Object.create显式设置">
<meta name="twitter:image" content="http://ecmadao.com/Coding-Guide/images/BetterJavaScriptWithES6/ebbd5e3.png">
    
    
        
          
              <link rel="shortcut icon" href="/Coding-Guide/images/favicon.ico">
          
        
        
          
            <link rel="icon" type="image/png" href="/Coding-Guide/images/favicon-192x192.png" sizes="192x192">
          
        
        
          
            <link rel="apple-touch-icon" sizes="180x180" href="/Coding-Guide/images/apple-touch-icon.png">
          
        
    
    <!-- title -->
    <title>【译文】用ES6写更赞的JavaScript（2）</title>
    <!-- styles -->
    <link rel="stylesheet" href="/Coding-Guide/lib/font-awesome/css/font-awesome.min.css">
    <link rel="stylesheet" href="/Coding-Guide/lib/meslo-LG/styles.css">
    <link rel="stylesheet" href="/Coding-Guide/lib/justified-gallery/justifiedGallery.min.css">
    <link rel="stylesheet" href="/Coding-Guide/css/style.css">
    <!-- rss -->
    
    
    <!-- jquery -->
    <script src="/Coding-Guide/lib/jquery/jquery.min.js"></script>
</head>

<body>
    
      <div id="header-post">
  <a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
         
          <li><a href="/Coding-Guide/">Home</a></li>
         
          <li><a href="/Coding-Guide/about/">About</a></li>
         
          <li><a href="/Coding-Guide/archives/">Articles</a></li>
         
          <li><a href="http://github.com/ecmadao">Projects</a></li>
        
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" href="/Coding-Guide/2017/01/13/Notes/译文/Javascript函数式编程/【译文】Javascript函数式编程【1】/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li>
        
        
        <li><a class="icon" href="/Coding-Guide/2017/01/13/Notes/译文/Javascript函数式编程/【译文】Javascript函数式编程【2】/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li>
        
        <li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li>
        <li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=http://ecmadao.com/Coding-Guide/2017/01/13/Notes/译文/ES6/【译文】用ES6写更赞的JavaScript（2）/"><i class="fa fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=http://ecmadao.com/Coding-Guide/2017/01/13/Notes/译文/ES6/【译文】用ES6写更赞的JavaScript（2）/&text=【译文】用ES6写更赞的JavaScript（2）"><i class="fa fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=http://ecmadao.com/Coding-Guide/2017/01/13/Notes/译文/ES6/【译文】用ES6写更赞的JavaScript（2）/&title=【译文】用ES6写更赞的JavaScript（2）"><i class="fa fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=http://ecmadao.com/Coding-Guide/2017/01/13/Notes/译文/ES6/【译文】用ES6写更赞的JavaScript（2）/&is_video=false&description=【译文】用ES6写更赞的JavaScript（2）"><i class="fa fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=【译文】用ES6写更赞的JavaScript（2）&body=Check out this article: http://ecmadao.com/Coding-Guide/2017/01/13/Notes/译文/ES6/【译文】用ES6写更赞的JavaScript（2）/"><i class="fa fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=http://ecmadao.com/Coding-Guide/2017/01/13/Notes/译文/ES6/【译文】用ES6写更赞的JavaScript（2）/&title=【译文】用ES6写更赞的JavaScript（2）"><i class="fa fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=http://ecmadao.com/Coding-Guide/2017/01/13/Notes/译文/ES6/【译文】用ES6写更赞的JavaScript（2）/&title=【译文】用ES6写更赞的JavaScript（2）"><i class="fa fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=http://ecmadao.com/Coding-Guide/2017/01/13/Notes/译文/ES6/【译文】用ES6写更赞的JavaScript（2）/&title=【译文】用ES6写更赞的JavaScript（2）"><i class="fa fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=http://ecmadao.com/Coding-Guide/2017/01/13/Notes/译文/ES6/【译文】用ES6写更赞的JavaScript（2）/&title=【译文】用ES6写更赞的JavaScript（2）"><i class="fa fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=http://ecmadao.com/Coding-Guide/2017/01/13/Notes/译文/ES6/【译文】用ES6写更赞的JavaScript（2）/&name=【译文】用ES6写更赞的JavaScript（2）&description="><i class="fa fa-tumblr " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#【译文】用ES6写更赞的JavaScript（2）"><span class="toc-number">1.</span> <span class="toc-text">【译文】用ES6写更赞的JavaScript（2）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#后退一步：类不是什么"><span class="toc-number">1.1.</span> <span class="toc-text">后退一步：类不是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#基础：声明-amp-表达式"><span class="toc-number">1.2.</span> <span class="toc-text">基础：声明&表达式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用extends创建子类-amp-调用super方法"><span class="toc-number">1.3.</span> <span class="toc-text">使用extends创建子类&调用super方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#深入原型"><span class="toc-number">1.4.</span> <span class="toc-text">深入原型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#使用构造函数创建对象"><span class="toc-number">1.4.1.</span> <span class="toc-text">使用构造函数创建对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#体验原型链"><span class="toc-number">1.4.2.</span> <span class="toc-text">体验原型链</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#给对象设置原型"><span class="toc-number">1.4.3.</span> <span class="toc-text">给对象设置原型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#名为对象的方法"><span class="toc-number">1.4.4.</span> <span class="toc-text">名为对象的方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#默认规则"><span class="toc-number">1.4.4.1.</span> <span class="toc-text">默认规则</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#通过new隐式设置"><span class="toc-number">1.4.4.2.</span> <span class="toc-text">通过new隐式设置</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#通过Object-create显式设置"><span class="toc-number">1.4.4.3.</span> <span class="toc-text">通过Object.create显式设置</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#模仿class"><span class="toc-number">1.5.</span> <span class="toc-text">模仿class</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#走进“方法”"><span class="toc-number">1.6.</span> <span class="toc-text">走进“方法”</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#类的构造方法"><span class="toc-number">1.6.1.</span> <span class="toc-text">类的构造方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#静态方法"><span class="toc-number">1.6.2.</span> <span class="toc-text">静态方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#属性方法"><span class="toc-number">1.6.3.</span> <span class="toc-text">属性方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#symbol方法"><span class="toc-number">1.6.4.</span> <span class="toc-text">symbol方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#总结"><span class="toc-number">1.7.</span> <span class="toc-text">总结</span></a></li></ol></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index width mx-auto px2 my4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        【译文】用ES6写更赞的JavaScript（2）
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">ecmadao</span>
      </span>
      
    <div class="postdate">
        <time datetime="2017-01-13T05:58:37.000Z" itemprop="datePublished">2017-01-13</time>
    </div>


      
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/Coding-Guide/tags/ES6/">ES6</a>, <a class="tag-link" href="/Coding-Guide/tags/译文/">译文</a>
    </div>


    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
<p><strong>Table of Contents</strong>  <em>generated with <a href="https://github.com/thlorenz/doctoc" target="_blank" rel="external">DocToc</a></em></p>
<ul>
<li><a href="#%E3%80%90%E8%AF%91%E6%96%87%E3%80%91%E7%94%A8es6%E5%86%99%E6%9B%B4%E8%B5%9E%E7%9A%84javascript%EF%BC%882%EF%BC%89">【译文】用ES6写更赞的JavaScript（2）</a><ul>
<li><a href="#%E5%90%8E%E9%80%80%E4%B8%80%E6%AD%A5%EF%BC%9A%E7%B1%BB%E4%B8%8D%E6%98%AF%E4%BB%80%E4%B9%88">后退一步：类不是什么</a></li>
<li><a href="#%E5%9F%BA%E7%A1%80%EF%BC%9A%E5%A3%B0%E6%98%8E&amp;%E8%A1%A8%E8%BE%BE%E5%BC%8F">基础：声明&amp;表达式</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8extends%E5%88%9B%E5%BB%BA%E5%AD%90%E7%B1%BB&amp;%E8%B0%83%E7%94%A8super%E6%96%B9%E6%B3%95">使用<code>extends</code>创建子类&amp;调用<code>super</code>方法</a></li>
<li><a href="#%E6%B7%B1%E5%85%A5%E5%8E%9F%E5%9E%8B">深入原型</a><ul>
<li><a href="#%E4%BD%BF%E7%94%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1">使用构造函数创建对象</a></li>
<li><a href="#%E4%BD%93%E9%AA%8C%E5%8E%9F%E5%9E%8B%E9%93%BE">体验原型链</a></li>
<li><a href="#%E7%BB%99%E5%AF%B9%E8%B1%A1%E8%AE%BE%E7%BD%AE%E5%8E%9F%E5%9E%8B">给对象设置原型</a></li>
<li><a href="#%E5%90%8D%E4%B8%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E6%B3%95">名为对象的方法</a><ul>
<li><a href="#%E9%BB%98%E8%AE%A4%E8%A7%84%E5%88%99">默认规则</a></li>
<li><a href="#%E9%80%9A%E8%BF%87new%E9%9A%90%E5%BC%8F%E8%AE%BE%E7%BD%AE">通过<code>new</code>隐式设置</a></li>
<li><a href="#%E9%80%9A%E8%BF%87objectcreate%E6%98%BE%E5%BC%8F%E8%AE%BE%E7%BD%AE">通过<code>Object.create</code>显式设置</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E6%A8%A1%E4%BB%BFclass">模仿class</a></li>
<li><a href="#%E8%B5%B0%E8%BF%9B%E2%80%9C%E6%96%B9%E6%B3%95%E2%80%9D">走进“方法”</a><ul>
<li><a href="#%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95">类的构造方法</a></li>
<li><a href="#%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95">静态方法</a></li>
<li><a href="#%E5%B1%9E%E6%80%A7%E6%96%B9%E6%B3%95">属性方法</a></li>
<li><a href="#symbol%E6%96%B9%E6%B3%95">symbol方法</a></li>
</ul>
</li>
<li><a href="#%E6%80%BB%E7%BB%93">总结</a></li>
</ul>
</li>
</ul>
<!-- END doctoc generated TOC please keep comment here to allow auto update -->
<h2 id="【译文】用ES6写更赞的JavaScript（2）"><a href="#【译文】用ES6写更赞的JavaScript（2）" class="headerlink" title="【译文】用ES6写更赞的JavaScript（2）"></a>【译文】用ES6写更赞的JavaScript（2）</h2><blockquote>
<p>本文译自：<a href="https://scotch.io/tutorials/better-javascript-with-es6-pt-ii-a-deep-dive-into-classes" target="_blank" rel="external">Better JavaScript with ES6, Pt. II: A Deep Dive into Classes</a></p>
</blockquote>
<p>开始之前首先要说明的一点是：</p>
<blockquote>
<p>ES6的class并不真的是全新的东西：它提供了方便的语法来创建方法。</p>
<p>– Axel Rauschmayer</p>
</blockquote>
<p>从功能上讲，<code>class</code>比我们很早就有的“以原型链为基础的委托关系”做的更多。这篇文章从原型关系出发，带你了解ES2015的<code>class</code>。包括以下几点：</p>
<ul>
<li>定义和实例化类</li>
<li>通过<code>extends</code>创建子类</li>
<li>子类中的<code>super</code></li>
<li>symbol方法的例子</li>
</ul>
<h3 id="后退一步：类不是什么"><a href="#后退一步：类不是什么" class="headerlink" title="后退一步：类不是什么"></a>后退一步：类不是什么</h3><p>JavaScript中的类跟Java、Python或者任何面向对象语言里的类有很大不同。</p>
<p>在传统的面向对象语言里，你创建的类是Object的模板。当你需要新的Object的时候，只要实例化类，引擎就会拷贝类里的属性和方法到新的实体中，称之为实例。实例是一个Object，而且在实例化之后与他的父类完全没有联系。</p>
<p>JavaScript没有这样的拷贝方法。在JavaScript中，实例化一个类也会生成新的Object，但并没有从父类独立。</p>
<p>反之，实例化的结果会连接到它的原型。即便已经实例化过了，改变原型还是会影响到这个新生成的Object。</p>
<p>原型在JavaScript设计模式中及其有用。通过它提供的一些方法可以达到模拟传统类的效果。</p>
<p>总结：</p>
<ol>
<li>JavaScript没有严格意义上的类</li>
<li>JavaScript中的类仅仅是创建原型链的语法糖</li>
</ol>
<p>来让我们深入了解js中的类吧。</p>
<h3 id="基础：声明-amp-表达式"><a href="#基础：声明-amp-表达式" class="headerlink" title="基础：声明&amp;表达式"></a>基础：声明&amp;表达式</h3><p>使用<code>class</code>和代码块创建类，称之为“类的声明”。在声明基类时不需要使用<code>extends</code>关键字：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="meta">"use strict"</span>;</div><div class="line"></div><div class="line"><span class="comment">// Food is a base class</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Food</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">constructor</span> (name, protein, carbs, fat) &#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">        <span class="keyword">this</span>.protein = protein;</div><div class="line">        <span class="keyword">this</span>.carbs = carbs;</div><div class="line">        <span class="keyword">this</span>.fat = fat;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    toString () &#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span> | <span class="subst">$&#123;<span class="keyword">this</span>.protein&#125;</span>g P :: <span class="subst">$&#123;<span class="keyword">this</span>.carbs&#125;</span>g C :: <span class="subst">$&#123;<span class="keyword">this</span>.fat&#125;</span>g F`</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    print () &#123;</div><div class="line">      <span class="built_in">console</span>.log( <span class="keyword">this</span>.toString() );</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> chicken_breast = <span class="keyword">new</span> Food(<span class="string">'Chicken Breast'</span>, <span class="number">26</span>, <span class="number">0</span>, <span class="number">3.5</span>);</div><div class="line"></div><div class="line">chicken_breast.print(); <span class="comment">// 'Chicken Breast | 26g P :: 0g C :: 3.5g F'</span></div><div class="line"><span class="built_in">console</span>.log(chicken_breast.protein); <span class="comment">// 26 (LINE A)</span></div></pre></td></tr></table></figure>
<p>需要注意的几点：</p>
<ul>
<li>类内只能包含方法，不能有属性</li>
<li>定义类的方法时，可以使用简写方法</li>
<li>与创建Object不同，类中的方法不需要用<code>,</code>分隔</li>
<li>可以使用类的原型链</li>
</ul>
<p>类中有一个特殊的方法叫作<code>constructor</code>，这是初始化属性的地方。</p>
<p>你不必总是自己写<code>constructor</code>方法，当你不写的时候引擎会自动帮你添加一个新的<code>constructor</code>方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">"use strict"</span>;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">NoConstructor</span> </span>&#123; </div><div class="line">    <span class="comment">/* JavaScript inserts something like this:</span></div><div class="line">     constructor () &#123; &#125;</div><div class="line">    */</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> nemo = <span class="keyword">new</span> NoConstructor(); <span class="comment">// Works, but pretty boring</span></div></pre></td></tr></table></figure>
<p>将类赋值给变量叫作类表达式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="meta">"use strict"</span>;</div><div class="line"></div><div class="line"><span class="comment">// 创建匿名class，无法在class内部使用它的名字</span></div><div class="line"><span class="keyword">const</span> Food = <span class="class"><span class="keyword">class</span> </span>&#123;</div><div class="line">    <span class="comment">// 内部的定义和之前的一样</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 命名class表达式，可以在内部使用它的名称FoodClass</span></div><div class="line"><span class="keyword">const</span> Food = <span class="class"><span class="keyword">class</span> <span class="title">FoodClass</span> </span>&#123;</div><div class="line">    <span class="comment">// 内部的定义和之前的一样</span></div><div class="line"></div><div class="line">    printMacronutrients () &#123;</div><div class="line">      <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;FoodClass.name&#125;</span> | <span class="subst">$&#123;FoodClass.protein&#125;</span> g P :: <span class="subst">$&#123;FoodClass.carbs&#125;</span> g C :: <span class="subst">$&#123;FoodClass.fat&#125;</span> g F`</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> chicken_breast = <span class="keyword">new</span> Food(<span class="string">'Chicken Breast'</span>, <span class="number">26</span>, <span class="number">0</span>, <span class="number">3.5</span>);</div><div class="line">chicken_breast.printMacronutrients(); <span class="comment">// 'Chicken Breast | 26g P :: 0g C :: 3.5g F'</span></div><div class="line"></div><div class="line"><span class="comment">// 但外部无法调用class的属性</span></div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">    <span class="built_in">console</span>.log(FoodClass.protein); <span class="comment">// ReferenceError </span></div><div class="line">&#125; <span class="keyword">catch</span> (err) &#123; </div><div class="line">    <span class="comment">// pass</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这与普通<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/function" target="_blank" rel="external">函数表达式</a>的表现一样。</p>
<h3 id="使用extends创建子类-amp-调用super方法"><a href="#使用extends创建子类-amp-调用super方法" class="headerlink" title="使用extends创建子类&amp;调用super方法"></a>使用<code>extends</code>创建子类&amp;调用<code>super</code>方法</h3><p>使用<code>extends</code>建立的类被称为子类。它的使用很简单。来瞅瞅例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">"use strict"</span>;</div><div class="line"></div><div class="line"><span class="comment">// FatFreeFood is a derived class</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">FatFreeFood</span> <span class="keyword">extends</span> <span class="title">Food</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span> (name, protein, carbs) &#123;</div><div class="line">        <span class="keyword">super</span>(name, protein, carbs, <span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line">    print () &#123;</div><div class="line">        <span class="keyword">super</span>.print(); </div><div class="line">        <span class="built_in">console</span>.log(<span class="string">`Would you look at that -- <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span> has no fat!`</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> fat_free_yogurt = <span class="keyword">new</span> FatFreeFood(<span class="string">'Greek Yogurt'</span>, <span class="number">16</span>, <span class="number">12</span>);</div><div class="line">fat_free_yogurt.print(); <span class="comment">// 'Greek Yogurt | 26g P :: 16g C :: 0g F  /  Would you look at that -- Greek Yogurt has no fat!'</span></div></pre></td></tr></table></figure>
<p>有几个要额外注意的点：</p>
<ul>
<li>子类通过<code>class</code>和<code>extends</code>关键字创建</li>
<li>如果要使用它扩展的父类，则需要使用<code>super</code>关键字</li>
<li><code>constructor</code>方法内不能为空，即使里面只调用了<code>spuer</code>方法。但你仍然可以不写<code>constructor</code>方法。</li>
<li>在使用<code>this</code>之前，必须在<code>constructor</code>内调用<code>super</code>方法</li>
</ul>
<p>在JavaScript中，有两个地方要用到<code>super</code>方法：</p>
<ol>
<li><strong>子类调用了<code>constructor</code>方法。</strong>如果需要通过调用父类的<code>constructor</code>方法才能实例化子类，你可以通过在子类的构造方法里调用<code>super(parentConstructorParams)</code>完成它。</li>
<li><strong>为了使用父类的方法。</strong>子类通过<code>super.methodName</code>可以调用父类里的方法。</li>
</ol>
<p>我们的例子<code>FatFreeFood</code>同时使用了这两种super方法：</p>
<ol>
<li>在构造方法内，调用<code>super</code>方法，并将0作为给父类的参数传入。</li>
<li>在<code>print</code>方法内，先调用了<code>super.print</code>方法，然后添加了额外的方法。</li>
</ol>
<p>不管你信不信，我们已经对<code>class</code>进行了基本的介绍了。这些就是你开始探索的基础。</p>
<h3 id="深入原型"><a href="#深入原型" class="headerlink" title="深入原型"></a>深入原型</h3><p>是时候了解<code>class</code>里原型链的机制了。我们将要学习：</p>
<ul>
<li>使用构造函数创建对象</li>
<li>原型链的本质</li>
<li>属性和委托方法</li>
<li>使用原型模仿class</li>
</ul>
<h4 id="使用构造函数创建对象"><a href="#使用构造函数创建对象" class="headerlink" title="使用构造函数创建对象"></a>使用构造函数创建对象</h4><p>构造函数并不是什么新东西。通过<code>new</code>关键字调用的方法都会返回一个对象–这种方法叫做构造方法。对应的函数叫做构造函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">"use strict"</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Food</span> (<span class="params">name, protein, carbs, fat</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">    <span class="keyword">this</span>.protein = protein;</div><div class="line">    <span class="keyword">this</span>.carbs = carbs;</div><div class="line">    <span class="keyword">this</span>.fat = fat;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 通过new关键字调用Food，返回一个对象</span></div><div class="line"><span class="keyword">const</span> chicken_breast = <span class="keyword">new</span> Food(<span class="string">'Chicken Breast'</span>, <span class="number">26</span>, <span class="number">0</span>, <span class="number">3.5</span>);</div><div class="line"><span class="built_in">console</span>.log(chicken_breast.protein) <span class="comment">// 26</span></div><div class="line"></div><div class="line"><span class="comment">// 直接调用则返回 'undefined'</span></div><div class="line"><span class="keyword">const</span> fish = Food(<span class="string">'Halibut'</span>, <span class="number">26</span>, <span class="number">0</span>, <span class="number">2</span>);</div><div class="line"><span class="built_in">console</span>.log(fish); <span class="comment">// 'undefined'</span></div></pre></td></tr></table></figure>
<p>当你使用<code>new</code>来调用函数的时候，会发生下面这些事情：</p>
<ol>
<li>创建新对象（就叫做 O 吧）</li>
<li>O与另一个对象建立联系，并叫它为<em>原型</em></li>
<li>函数的<code>this</code>指向 O</li>
<li>函数最后返回 O</li>
</ol>
<p>在第三第四步中间，引擎负责处理函数的逻辑。</p>
<p>知道了这些之后，我们可以重写<code>Food</code>方法，并使其实例化时不必使用<code>new</code>关键字：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="meta">"use strict"</span>;</div><div class="line"></div><div class="line"><span class="comment">// Eliminating the need for 'new' -- just for demonstration</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Food</span> (<span class="params">name, protein, carbs, fat</span>) </span>&#123;</div><div class="line">       <span class="comment">// Step One: Create a new Object</span></div><div class="line">    <span class="keyword">const</span> obj = &#123; &#125;; </div><div class="line">    <span class="comment">// Step Two: Link prototypes -- we'll cover this in greater detail shortly</span></div><div class="line">    <span class="built_in">Object</span>.setPrototypeOf(obj, Food.prototype);</div><div class="line">    <span class="comment">// Step Three: Set 'this' to point to our new Object</span></div><div class="line">    <span class="comment">// Since we can't reset `this` inside of a running execution context, we simulate Step Three by using 'obj' instead of 'this'</span></div><div class="line">    obj.name = name;</div><div class="line">    obj.protein = protein;</div><div class="line">    obj.carbs = carbs;</div><div class="line">    obj.fat = fat;</div><div class="line">    <span class="comment">// Step Four: Return the newly created object</span></div><div class="line">    <span class="keyword">return</span> obj;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> fish = Food(<span class="string">'Halibut'</span>, <span class="number">26</span>, <span class="number">0</span>, <span class="number">2</span>);</div><div class="line"><span class="built_in">console</span>.log(fish.protein); <span class="comment">// 26</span></div></pre></td></tr></table></figure>
<p>四个步骤中有三步都很简单：创建对象（第一步），设置this和属性（第三步），返回对象（第四步）。而第二部的原型往往让人们却步。</p>
<h4 id="体验原型链"><a href="#体验原型链" class="headerlink" title="体验原型链"></a>体验原型链</h4><p>在正常状态下，JavaScript里的所有对象–包括方法–都连接到了另一个对象上，我们称之为原型。</p>
<p>如果你调用了对象上不存在的属性，JavaScript会在该对象的原型里寻找这个属性。换句话说，当对象上的属性不存在是，它就会说：“咱不知道。去问我的原型吧。”</p>
<p>这个过程–向其他对象查找不存在的属性–叫作<strong>委托</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">"use strict"</span>;</div><div class="line"></div><div class="line"><span class="comment">// joe 并没有toString方法</span></div><div class="line"><span class="keyword">const</span> joe    = &#123; <span class="attr">name</span> : <span class="string">'Joe'</span> &#125;,</div><div class="line">       sara  = &#123; <span class="attr">name</span> : <span class="string">'Sara'</span> &#125;;</div><div class="line"></div><div class="line"><span class="built_in">Object</span>.hasOwnProperty(joe, toString); <span class="comment">// false</span></div><div class="line"><span class="built_in">Object</span>.hasOwnProperty(sara, toString); <span class="comment">// false</span></div><div class="line"></div><div class="line"><span class="comment">// 但我们仍能调用它！</span></div><div class="line">joe.toString(); <span class="comment">// '[object Object]', 而不是 ReferenceError!</span></div><div class="line">sara.toString(); <span class="comment">// '[object Object]', 而不是 ReferenceError!</span></div></pre></td></tr></table></figure>
<p>我们的<code>toString</code>方法应该完全没用，但它没有引起<code>ReferenceError</code>。那是因为虽然joe和sara没有toString方法，但他们的原型有。之后JavaScript询问<code>Object.prototype</code>是否有<code>toString</code>方法。在得到确定的回答之后，它将<code>Object.prototype</code>的<code>toString</code>方法作为最初的调用。</p>
<p>虽然sara自己没有相应的方法但这无所谓–我们委托给了它的原型。</p>
<p>换句话说，只要对象的原型里有我们想要的方法，我们就能从对象那里进行调用。那样的话，我们可以把属性和方法放在它的原型里，然后好像它们存在对象里面一样，正常的通过对象来进行调用。</p>
<p>还有更赞的。如果一些对象有共同的原型–就好像上面的joe和sara–它们可以通过原型共享同样的属性和方法，而不需要进行任何的拷贝。</p>
<p>这就是人们经常提及的原型继承–如果我的对象没有，但是对象的原型有，那么它就能从原型继承自己所需的。</p>
<p>实际上，不存在任何的继承。在面向对象的语言里，继承暗示着子类的行为是从父类拷贝而来。而在JavaScript中，没有拷贝这样的行为–事实上，这是通过JavaScript class 里的原型获取的最大优势之一。</p>
<p>快速的梳理一下：</p>
<ul>
<li>joe和sara并没有继承<code>toString</code>方法</li>
<li>事实上，joe和sara也没有继承<code>Object.prototype</code></li>
<li>joe和sara连接到了<code>Object.prototype</code></li>
<li>joe和sara连接着同样的<code>Object.prototype</code></li>
<li>为了寻找原型–暂且把原型称之为O–调用：<code>Object.getPrototypeOf(O)</code></li>
</ul>
<p>最后再强调一点：对象不继承他们的原型，而是委托它们。</p>
<p>来让我们再深入一下。</p>
<h4 id="给对象设置原型"><a href="#给对象设置原型" class="headerlink" title="给对象设置原型"></a>给对象设置原型</h4><p>我们已经知道了（几乎）所有的对象（O）都有原型（P），而当你在O上寻找它没有的属性时，JavaScript引擎会在P身上进行查询。</p>
<p>那么问题是：</p>
<ol>
<li>对于方法而言，如果运行这一套机制？</li>
<li>这些原型究竟是从哪儿来的？</li>
</ol>
<h4 id="名为对象的方法"><a href="#名为对象的方法" class="headerlink" title="名为对象的方法"></a>名为对象的方法</h4><p>在JavaScript执行程序之前，它会创建一个运行的环境，在那里面建立了一个叫做<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object" target="_blank" rel="external"><code>Object</code></a>的函数。而与它联系的对象，则叫做 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/prototype" target="_blank" rel="external"><code>Object.prototype</code></a></p>
<p>换句话说，在一段执行的JavaScript程序中，<code>Object</code>和<code>Object.prototype</code>是一直存在的。</p>
<p>这个函数（Object）跟其他的方法不同。它是一个构造函数–调用它则会返回一个新的对象：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">"use strict"</span>;</div><div class="line"></div><div class="line"><span class="keyword">typeof</span> <span class="keyword">new</span> <span class="built_in">Object</span>(); <span class="comment">// "object"</span></div><div class="line"><span class="keyword">typeof</span> <span class="built_in">Object</span>(); <span class="comment">// Object function 的一个奇特之处是它不需要通过 new 调用</span></div></pre></td></tr></table></figure>
<p><code>Object</code>,<code>Object.prototype</code>都是对象，就跟其他对象一样拥有属性。</p>
<p><img src="/Coding-Guide/images/BetterJavaScriptWithES6/ebbd5e3.png" alt="properties in Object.prototype"></p>
<p>关于<code>Object</code>和<code>Object.prototype</code>你需要知道的几点：</p>
<ol>
<li>那个叫Object的函数有个属性，叫作<code>.prototype</code>，指向了一个对象。</li>
<li>而这个<code>Object.prototype</code>对象，有一个属性<code>.constructor</code>，指向<code>Object</code>这个函数</li>
</ol>
<p>因此当你创建函数的时候–举个例子，<code>someFunction</code>–它将会有一个<code>prototype</code>属性，指向<code>someFunction.prototype</code>对象。</p>
<p>反之，那个对象–<code>meFunction.prototype</code>–拥有一个名为<code>.constructor</code>的属性，返回<code>someFunction</code>方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">"use strict"</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123;  <span class="built_in">console</span>.log(<span class="string">'Foo!'</span>);  &#125;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(foo.prototype); <span class="comment">// Points to an object called 'foo'</span></div><div class="line"><span class="built_in">console</span>.log(foo.prototype.constructor); <span class="comment">// Points to the function, 'foo'</span></div><div class="line"></div><div class="line">foo.prototype.constructor(); <span class="comment">// Prints 'Foo!' -- just proving that 'foo.prototype.constructor' does, in fact, point to our original function</span></div></pre></td></tr></table></figure>
<p>要牢记的几点：</p>
<ol>
<li>所有的函数都有<code>prototype</code>属性，指向一个与该函数联系的对象</li>
<li>函数的原型都有一个叫做<code>constructor</code>的属性，指回这个函数</li>
<li>函数原型的<code>constructor</code>不需要一定指向创建函数原型的方法</li>
</ol>
<p>关于设置函数的原型有三条规则：</p>
<ol>
<li>默认规则</li>
<li>通过<code>new</code>隐式设置</li>
<li>通过<code>Object.create</code>显式设置</li>
</ol>
<h5 id="默认规则"><a href="#默认规则" class="headerlink" title="默认规则"></a>默认规则</h5><p>看下这段代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">"use strict"</span>;</div><div class="line"><span class="keyword">const</span> foo = &#123; <span class="attr">status</span> : <span class="string">'foobar'</span> &#125;;</div></pre></td></tr></table></figure>
<p>非常简单。我们只是创建了一个叫<code>foo</code>的对象，并给了它一个叫<code>status</code>的属性。</p>
<p>但是在这背后，JavaScript做了一些额外的工作。当我们直接创建一盒对象时，JavaScript会把对象的原型设置成<code>Object.prototype</code>，并把这个对象的<code>constructor</code>设置为<code>Object</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">"use strict"</span>;</div><div class="line"><span class="keyword">const</span> foo = &#123; <span class="attr">status</span> : <span class="string">'foobar'</span> &#125;;</div><div class="line"><span class="built_in">Object</span>.getPrototypeOf(foo) === <span class="built_in">Object</span>.prototype; <span class="comment">// true</span></div><div class="line">foo.constructor === <span class="built_in">Object</span>; <span class="comment">// true</span></div></pre></td></tr></table></figure>
<h5 id="通过new隐式设置"><a href="#通过new隐式设置" class="headerlink" title="通过new隐式设置"></a>通过<code>new</code>隐式设置</h5><p>再来看看<code>Food</code>这个例子</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">"use strict"</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Food</span> (<span class="params">name, protein, carbs, fat</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">    <span class="keyword">this</span>.protein = protein;</div><div class="line">    <span class="keyword">this</span>.carbs = carbs;</div><div class="line">    <span class="keyword">this</span>.fat = fat;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们已经知道这个Food函数会与名为<code>Food.prototype</code>的对象关联。</p>
<p>当我们使用<code>new</code>创建对象的时候：</p>
<ol>
<li>将<code>prototype</code>属性加到通过<code>new</code>声明的函数上。</li>
<li>将<code>constructor</code>属性加到<code>new</code>声明的函数上。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> tootsie_roll = <span class="keyword">new</span> Food(<span class="string">'Tootsie Roll'</span>, <span class="number">0</span>, <span class="number">26</span>, <span class="number">0</span>);</div><div class="line"></div><div class="line"><span class="built_in">Object</span>.getPrototypeOf(tootsie_roll) === Food.prototype; <span class="comment">// true</span></div><div class="line">tootsie_roll.constructor === Food; <span class="comment">// true</span></div></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">"use strict"</span>;</div><div class="line">Food.prototype.cook = <span class="function"><span class="keyword">function</span> <span class="title">cook</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span> is cooking!`</span>);</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">const</span> dinner = <span class="keyword">new</span> Food(<span class="string">'Lamb Chops'</span>, <span class="number">52</span>, <span class="number">8</span>, <span class="number">32</span>);</div><div class="line">dinner.cook(); <span class="comment">// 'Lamb Chops are cooking!'</span></div></pre></td></tr></table></figure>
<h5 id="通过Object-create显式设置"><a href="#通过Object-create显式设置" class="headerlink" title="通过Object.create显式设置"></a>通过<code>Object.create</code>显式设置</h5><p>我们可以通过<code>Object.create</code>手动设置原型。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">"use strict"</span>;</div><div class="line"><span class="keyword">const</span> foo = &#123;</div><div class="line">    speak () &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'Foo!'</span>);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">const</span> bar = <span class="built_in">Object</span>.create(foo);</div><div class="line"></div><div class="line">bar.speak(); <span class="comment">// 'Foo!'</span></div><div class="line"><span class="built_in">Object</span>.getPrototypeOf(bar) === foo; <span class="comment">// true</span></div></pre></td></tr></table></figure>
<p>当你这么调用的时候：</p>
<ol>
<li>创建新对象</li>
<li>设置原型</li>
<li>返回这个新对象</li>
</ol>
<p>在这里查看<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create" target="_blank" rel="external">MDN上<code>Object.create()</code>的讲解</a></p>
<h3 id="模仿class"><a href="#模仿class" class="headerlink" title="模仿class"></a>模仿class</h3><p>直接使用原型来模拟面向对象的行为需要很多技巧。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="meta">"use strict"</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Food</span> (<span class="params">name, protein, carbs, fat</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">    <span class="keyword">this</span>.protein = protein;</div><div class="line">    <span class="keyword">this</span>.carbs = carbs;</div><div class="line">    <span class="keyword">this</span>.fat = fat;</div><div class="line">&#125;</div><div class="line">Food.prototype.toString = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span> | <span class="subst">$&#123;<span class="keyword">this</span>.protein&#125;</span>g P :: <span class="subst">$&#123;<span class="keyword">this</span>.carbs&#125;</span>g C :: <span class="subst">$&#123;<span class="keyword">this</span>.fat&#125;</span>g F`</span>;</div><div class="line">&#125;;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">FatFreeFood</span> (<span class="params">name, protein, carbs</span>) </span>&#123;</div><div class="line">    Food.call(<span class="keyword">this</span>, name, protein, carbs, <span class="number">0</span>);</div><div class="line">&#125;</div><div class="line"><span class="comment">// Setting up "subclass" relationships</span></div><div class="line"><span class="comment">// =====================</span></div><div class="line"><span class="comment">// LINE A :: 运用 Object.create 手动给 FatFreeFood设置 "parent".</span></div><div class="line">FatFreeFood.prototype = <span class="built_in">Object</span>.create(Food.prototype);</div><div class="line"></div><div class="line"><span class="comment">// LINE B :: 手动设置 constructor reference (!)</span></div><div class="line"><span class="built_in">Object</span>.defineProperty(FatFreeFood.constructor, <span class="string">"constructor"</span>, &#123;</div><div class="line">    <span class="attr">enumerable</span>: <span class="literal">false</span>,</div><div class="line">    <span class="attr">writeable</span>: <span class="literal">true</span>,</div><div class="line">    <span class="attr">value</span>: FatFreeFood</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>在LineA，我们将<code>FatFreeFood.prototype</code>设置成了一个新的对象。新对象的原型连接到<code>Food.prototype</code>。如果没有做这一步，那么子类就不能使用父类的方法。</p>
<p>但奇怪的是，<code>FatFreeFood.constructor</code>是个方法，而不是<code>FatFreeFod</code>。因此，我们在LineB手动设置构造函数。</p>
<p>通过原型去模仿真正的类就是<code>class</code>的动机之一。它确实也给我们提供了便捷的语法。</p>
<h3 id="走进“方法”"><a href="#走进“方法”" class="headerlink" title="走进“方法”"></a>走进“方法”</h3><p>现在我们已经知道了JavaScript原型系统的必要性，那么来看看三个它支持的方法，以及一个特殊的方法。</p>
<ul>
<li>构造方法</li>
<li>静态方法</li>
<li>原型方法</li>
<li>Symbol方法，一种特殊的原型方法</li>
</ul>
<h4 id="类的构造方法"><a href="#类的构造方法" class="headerlink" title="类的构造方法"></a>类的构造方法</h4><p>类的构造方法是你关注类初始化逻辑的地方。构造方法在几个地方比较特殊：</p>
<ol>
<li>它是类里面唯一可以调用父类构造方法的地方</li>
<li>它干了所有设置原型链的脏活</li>
<li>它通常作为类的定义。类的初始化逻辑写在构造函数内。</li>
</ol>
<p>第二点是运用JavaScript类这个概念的核心原则。引用《Exploring ES6》里面的一句话：</p>
<blockquote>
<p>子类的原型指向父类</p>
</blockquote>
<p>第三点很有意思。在JavaScript中，类仅仅是个方法–它相当于类中的<code>constructor</code>方法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">"use strict"</span>;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Food</span> </span>&#123;</div><div class="line">    <span class="comment">// Class definition is the same as before . . . </span></div><div class="line">&#125;</div><div class="line"><span class="keyword">typeof</span> Food; <span class="comment">// 'function'</span></div></pre></td></tr></table></figure>
<p>与普通方法不同的是，你只能通过<code>new</code>关键字来调用构造方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> burrito = Food(<span class="string">'Heaven'</span>, <span class="number">100</span>, <span class="number">100</span>, <span class="number">25</span>); <span class="comment">// TypeError</span></div></pre></td></tr></table></figure>
<p>这引出了另一个问题：当我们没有使用<code>new</code>的时候发送了什么？</p>
<p>简单的答案：就像其他没有明确返回值的函数一样，它返回了<code>undefined</code>。因此你必须相信开发者会通过构造函数来调用函数。这也就是为什么js委员会建议使用首字母大写的方式来命名：提醒你使用<code>new</code>关键字。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">"use strict"</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Food</span> (<span class="params">name, protein, carbs, fat</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name    = name;</div><div class="line">    <span class="keyword">this</span>.protein = protein;</div><div class="line">    <span class="keyword">this</span>.carbs    = carbs;</div><div class="line">    <span class="keyword">this</span>.fat          = fat;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> fish = Food(<span class="string">'Halibut'</span>, <span class="number">26</span>, <span class="number">0</span>, <span class="number">2</span>); <span class="comment">// D'oh . . .</span></div><div class="line"><span class="built_in">console</span>.log(fish); <span class="comment">// 'undefined'</span></div></pre></td></tr></table></figure>
<p>ES2015提供了一个方法：<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/new.target" target="_blank" rel="external"><code>new.target</code></a>，它可以让你监测实例是否是通过<code>new</code>调用的。</p>
<p><code>new.target</code>是通过<code>new</code>关键字调用的函数所拥有的一个属性。当你通过<code>new</code>调用一个方法的时候，方法内的<code>new.target</code>将指向该函数自身。而如果没有通过<code>new</code>调用，则这个属性的值是<code>undefined</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">"use strict"</span>;</div><div class="line"></div><div class="line"><span class="comment">// Enforcing constructor call</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Food</span> (<span class="params">name, protein, carbs, fat</span>) </span>&#123;</div><div class="line">    <span class="comment">// 通过检测，人为的使用new</span></div><div class="line">    <span class="keyword">if</span> (!<span class="keyword">new</span>.target)</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Food(name, protein, carbs, fat); </div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">    <span class="keyword">this</span>.protein = protein;</div><div class="line">    <span class="keyword">this</span>.carbs = carbs;</div><div class="line">    <span class="keyword">this</span>.fat = fat;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> fish = Food(<span class="string">'Halibut'</span>, <span class="number">26</span>, <span class="number">0</span>, <span class="number">2</span>); <span class="comment">// Oops -- but, no problem!</span></div><div class="line">fish; <span class="comment">// 'Food &#123;name: "Halibut", protein: 20, carbs: 5, fat: 0&#125;'</span></div></pre></td></tr></table></figure>
<p>在ES5中则不能更糟了：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">"use strict"</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Food</span> (<span class="params">name, protein, carbs, fat</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (!(<span class="keyword">this</span> <span class="keyword">instanceof</span> Food))</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Food(name, protein, carbs, fat); </div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">    <span class="keyword">this</span>.protein = protein;</div><div class="line">    <span class="keyword">this</span>.carbs = carbs;</div><div class="line">    <span class="keyword">this</span>.fat = fat;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/new.target" target="_blank" rel="external">MDN文档</a>对于<code>new.target</code>有更详细的介绍。</p>
<h4 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h4><p>静态方法是构造函数上的方法，它对于实例化的类而言不可用。你可以通过<code>static</code>关键字定义它。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">"use strict"</span>;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Food</span> </span>&#123;</div><div class="line">     <span class="comment">// Class definition is the same as before . . . </span></div><div class="line">     <span class="keyword">static</span> describe () &#123;</div><div class="line">       <span class="built_in">console</span>.log(<span class="string">'"Food" is a data type for storing macronutrient information.'</span>);</div><div class="line">      &#125;</div><div class="line">&#125;</div><div class="line">Food.describe(); <span class="comment">// '"Food" is a data type for storing macronutrient information.'</span></div></pre></td></tr></table></figure>
<p>静态方法与直接将属性加在函数身上有所类似：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta">"use strict"</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Food</span> (<span class="params">name, protein, carbs, fat</span>) </span>&#123;</div><div class="line">    Food.count += <span class="number">1</span>;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">    <span class="keyword">this</span>.protein = protein;</div><div class="line">    <span class="keyword">this</span>.carbs = carbs;</div><div class="line">    <span class="keyword">this</span>.fat = fat;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Food.count = <span class="number">0</span>;</div><div class="line">Food.describe = <span class="function"><span class="keyword">function</span> <span class="title">count</span> (<span class="params"></span>) </span>&#123;</div><div class="line">       <span class="built_in">console</span>.log(<span class="string">`You've created <span class="subst">$&#123;Food.count&#125;</span> food(s).`</span>);</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">const</span> dummy = <span class="keyword">new</span> Food();</div><div class="line">Food.describe(); <span class="comment">// "You've created 1 food."</span></div></pre></td></tr></table></figure>
<h4 id="属性方法"><a href="#属性方法" class="headerlink" title="属性方法"></a>属性方法</h4><p>不是构造方法或者静态方法的方法都叫做属性方法。它的名字来源自我们将方法当做属性一样的附加在函数的原型身上：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="meta">"use strict"</span>;</div><div class="line"></div><div class="line"><span class="comment">// Using ES6:</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Food</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span> (name, protein, carbs, fat) &#123;</div><div class="line">      <span class="keyword">this</span>.name = name;</div><div class="line">      <span class="keyword">this</span>.protein = protein;</div><div class="line">      <span class="keyword">this</span>.carbs = carbs;</div><div class="line">      <span class="keyword">this</span>.fat = fat;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    toString () &#123;  </div><div class="line">      <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span> | <span class="subst">$&#123;<span class="keyword">this</span>.protein&#125;</span>g P :: <span class="subst">$&#123;<span class="keyword">this</span>.carbs&#125;</span>g C :: <span class="subst">$&#123;<span class="keyword">this</span>.fat&#125;</span>g F`</span>; </div><div class="line">    &#125;</div><div class="line"></div><div class="line">    print () &#123;  </div><div class="line">      <span class="built_in">console</span>.log( <span class="keyword">this</span>.toString() );  </div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// In ES5:</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Food</span>  (<span class="params">name, protein, carbs, fat</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">    <span class="keyword">this</span>.protein = protein;</div><div class="line">    <span class="keyword">this</span>.carbs = carbs;</div><div class="line">    <span class="keyword">this</span>.fat = fat;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// "prototype methods" 来源于我们把方法像属性一样的加在函数的原型身上。</span></div><div class="line">Food.prototype.toString = <span class="function"><span class="keyword">function</span> <span class="title">toString</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span> | <span class="subst">$&#123;<span class="keyword">this</span>.protein&#125;</span>g P :: <span class="subst">$&#123;<span class="keyword">this</span>.carbs&#125;</span>g C :: <span class="subst">$&#123;<span class="keyword">this</span>.fat&#125;</span>g F`</span>; </div><div class="line">&#125;;</div><div class="line"></div><div class="line">Food.prototype.print = <span class="function"><span class="keyword">function</span> <span class="title">print</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log( <span class="keyword">this</span>.toString() ); </div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>为了更加简洁，我们可以在方法里添加生成器：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="meta">"use strict"</span>;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Range</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(from, to) &#123;</div><div class="line">    <span class="keyword">this</span>.from = <span class="keyword">from</span>;</div><div class="line">    <span class="keyword">this</span>.to = to;</div><div class="line">  &#125;</div><div class="line">  * generate () &#123;</div><div class="line">    <span class="keyword">let</span> counter = <span class="keyword">this</span>.from,</div><div class="line">        to = <span class="keyword">this</span>.to;</div><div class="line">    <span class="keyword">while</span> (counter &lt; to) &#123;</div><div class="line">      <span class="keyword">if</span> (counter == to)</div><div class="line">        <span class="keyword">return</span> counter++;</div><div class="line">      <span class="keyword">else</span></div><div class="line">        <span class="keyword">yield</span> counter++;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> range = <span class="keyword">new</span> Range(<span class="number">0</span>, <span class="number">3</span>);</div><div class="line"><span class="keyword">const</span> gen = range.generate();</div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> val <span class="keyword">of</span> range.generate()) &#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">`Generator value is: <span class="subst">$&#123; val &#125;</span>. `</span>);</div><div class="line">  <span class="comment">//  Prints:</span></div><div class="line">  <span class="comment">//    Generator value is: 0.</span></div><div class="line">  <span class="comment">//    Generator value is: 1.</span></div><div class="line">  <span class="comment">//    Generator value is: 2.</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="symbol方法"><a href="#symbol方法" class="headerlink" title="symbol方法"></a>symbol方法</h4><p>最终我们来学习下<code>Symbol</code>方法。它们是名为<code>Symbol</code>的方法，JavaScript引擎会据此识别出它，并且当你在自定义对象中使用内置构造方法的时候进行调用。</p>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol" target="_blank" rel="external">MDN文档</a>对Symbol进行了简要的介绍：</p>
<blockquote>
<p>每个symbol都是独特且不可变的数据类型，可以作为对象属性的标识符。</p>
</blockquote>
<p>新建一个symbol会返还给你一个绝对独特的值，它对于创建对象属性的名称而言非常有用：不会有偶然的命名重复。拿symbol做key也使得它不可数，因此对外部而言不可见（<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect/ownKeys" target="_blank" rel="external">并不是完全不可见</a>）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">"use strict"</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> secureObject = &#123;</div><div class="line">    <span class="comment">// 这个key是独一无二的</span></div><div class="line">    [<span class="keyword">new</span> <span class="built_in">Symbol</span>(<span class="string">"name"</span>)] : <span class="string">'Dr. Secure A. F.'</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log( <span class="built_in">Object</span>.getKeys(superSecureObject) ); <span class="comment">// [] -- 无法获取symbol</span></div><div class="line"><span class="built_in">console</span>.log( <span class="built_in">Reflect</span>.ownKeys(secureObject) ); <span class="comment">// [Symbol("name")] -- . . . 但也不是真的完全不可见</span></div></pre></td></tr></table></figure>
<p>对我们而言的好处是，它给我们了一种方法去告诉JavaScript引擎，在某些特定的目的下使用特定的方法。</p>
<p>当你在自定义对象中使用内置构造方法的时候，JavaScript引擎会调用这个特殊Symbol方法。这个特性在JavaScript中充满诱惑。我们来看个例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="meta">"use strict"</span>;</div><div class="line"><span class="comment">// 通过扩展Array使得可以使用length属性，同时也使我们可以使用Array的内置方法，比如map, filter, reduce, push, pop等</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">FoodSet</span> <span class="keyword">extends</span> <span class="title">Array</span> </span>&#123;</div><div class="line">    <span class="comment">// ...foods 用于获取全部参数并将其转为Array</span></div><div class="line">    <span class="comment">//   https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator</span></div><div class="line">    <span class="keyword">constructor</span>(...foods) &#123;</div><div class="line">        <span class="keyword">super</span>();</div><div class="line">        <span class="keyword">this</span>.foods = [];</div><div class="line">        foods.forEach(<span class="function">(<span class="params">food</span>) =&gt;</span> <span class="keyword">this</span>.foods.push(food))</div><div class="line">    &#125;</div><div class="line">     <span class="comment">// 自定义的迭代行为。虽然不是很有用，但是个好例子。</span></div><div class="line">     <span class="comment">// 星号（*）必须写在key前面</span></div><div class="line">     * [<span class="built_in">Symbol</span>.iterator] () &#123;</div><div class="line">        <span class="keyword">let</span> position = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span> (position &lt; <span class="keyword">this</span>.foods.length) &#123;</div><div class="line">          <span class="keyword">if</span> (position === <span class="keyword">this</span>.foods.length) &#123;</div><div class="line">              <span class="keyword">return</span> <span class="string">"Done!"</span></div><div class="line">          &#125; <span class="keyword">else</span> &#123;</div><div class="line">              <span class="keyword">yield</span> <span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.foods[ position++ ]&#125;</span> is the food item at position <span class="subst">$&#123;position&#125;</span>`</span>;</div><div class="line">          &#125;</div><div class="line">         &#125;</div><div class="line">     &#125;</div><div class="line">      <span class="comment">// 当用户使用Array内置的方法时，返回Array类型的对象而不是FoodSet</span></div><div class="line">      <span class="comment">// 这使得当我们使用一段期望返回Array的代码时，FoodSet可以正常工作</span></div><div class="line">      <span class="keyword">static</span> get [<span class="built_in">Symbol</span>.species] () &#123;</div><div class="line">          <span class="keyword">return</span> <span class="built_in">Array</span>;</div><div class="line">      &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> foodset = <span class="keyword">new</span> FoodSet(<span class="keyword">new</span> Food(<span class="string">'Fish'</span>, <span class="number">26</span>, <span class="number">0</span>, <span class="number">16</span>), <span class="keyword">new</span> Food(<span class="string">'Hamburger'</span>, <span class="number">26</span>, <span class="number">48</span>, <span class="number">24</span>));</div><div class="line"></div><div class="line"><span class="comment">// 当你对 FoodSet 调用 for...of 循环时, JavaScript 会使用你的 [Symbol.iterator]方法</span></div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> food <span class="keyword">of</span> foodset) &#123;</div><div class="line">  <span class="comment">// Prints all of our foods</span></div><div class="line">  <span class="built_in">console</span>.log( food );</div><div class="line">&#125;</div><div class="line"><span class="comment">// 当你对一个array调用filter函数的时候，它会根据你“filter”的对象，调用默认的构造方法，创建并返回新的对象。</span></div><div class="line"><span class="comment">// </span></div><div class="line"><span class="comment">// 通常来说，大多数的代码都会期待filter返回一个Array，因此，我们可以含蓄的通过新建一个重写[Symbol.species]的实例，告诉JavaScript引擎去使用Array的构造方法。</span></div><div class="line"><span class="keyword">const</span> healthy_foods = foodset.filter(<span class="function">(<span class="params">food</span>) =&gt;</span> food.name !== <span class="string">'Hamburger'</span>);</div><div class="line"><span class="built_in">console</span>.log( healthy_foods <span class="keyword">instanceof</span> FoodSet );</div><div class="line"><span class="built_in">console</span>.log( healthy_foods <span class="keyword">instanceof</span> <span class="built_in">Array</span> );</div></pre></td></tr></table></figure>
<p>当你对某个对象调用<code>for...of</code>循环的时候，JavaScript会试着执行对象的<code>iterator</code>方法。它与<code>Symbol.iterator</code>这个key所对应的方法相关联。如果你对这个方法提供了自己的定义那么JavaScript就会使用它，否则就使用默认的（如果有的话）。</p>
<p><code>Symbol.species</code>方法同样充满诱惑。在一个自定义的class内，默认的<code>Symbol.species</code>是这个类的构造函数。但是当你的子类扩展自数列时，比如说<code>Array</code>或者<code>Set</code>，你可能经常想要在可以使用父类实例的地方调用你的子类。</p>
<p>通过返回一个父类实例而不是子类，使得我们可以在子类里书写更加通用的代码。这就是<code>Symbol.species</code>可以做到的。</p>
<p>即便它没能发挥太大作用，也不要嗤之以鼻。symbol依旧是个新生的生态。而上面例子里的核心要点是：</p>
<ol>
<li>你可以在自定义类里使用确定了内置函数</li>
<li>如何达到这个目的</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>ES2015的<code>class</code>并没有真的给我们带来了类，而是一种更加简便创建对象的语法。在它的底层没有什么新的东西。</p>
<p>虽然我说了不少关于JavaScript原型的对象，但还有很多没能讲到。你可以查看Kyle Simpson的<a href="https://github.com/getify/You-Dont-Know-JS/tree/master/this%20%26%20object%20prototypes" target="_blank" rel="external">this &amp; Object Prototypes</a>进一步学习。</p>
<p>Dr Rauschmayer的<a href="http://exploringjs.com/es6/ch_classes.html" target="_blank" rel="external">Exploring ES6: Classes</a>值得一看。它是我写这篇文章时的灵感来源。</p>

  </div>
</article>

    <div class="blog-post-comments">
        <div id="disqus_thread">
            <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        </div>
    </div>



    </div>
    
      <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/Coding-Guide/">Home</a></li>
         
          <li><a href="/Coding-Guide/about/">About</a></li>
         
          <li><a href="/Coding-Guide/archives/">Articles</a></li>
         
          <li><a href="http://github.com/ecmadao">Projects</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#【译文】用ES6写更赞的JavaScript（2）"><span class="toc-number">1.</span> <span class="toc-text">【译文】用ES6写更赞的JavaScript（2）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#后退一步：类不是什么"><span class="toc-number">1.1.</span> <span class="toc-text">后退一步：类不是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#基础：声明-amp-表达式"><span class="toc-number">1.2.</span> <span class="toc-text">基础：声明&表达式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用extends创建子类-amp-调用super方法"><span class="toc-number">1.3.</span> <span class="toc-text">使用extends创建子类&调用super方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#深入原型"><span class="toc-number">1.4.</span> <span class="toc-text">深入原型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#使用构造函数创建对象"><span class="toc-number">1.4.1.</span> <span class="toc-text">使用构造函数创建对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#体验原型链"><span class="toc-number">1.4.2.</span> <span class="toc-text">体验原型链</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#给对象设置原型"><span class="toc-number">1.4.3.</span> <span class="toc-text">给对象设置原型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#名为对象的方法"><span class="toc-number">1.4.4.</span> <span class="toc-text">名为对象的方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#默认规则"><span class="toc-number">1.4.4.1.</span> <span class="toc-text">默认规则</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#通过new隐式设置"><span class="toc-number">1.4.4.2.</span> <span class="toc-text">通过new隐式设置</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#通过Object-create显式设置"><span class="toc-number">1.4.4.3.</span> <span class="toc-text">通过Object.create显式设置</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#模仿class"><span class="toc-number">1.5.</span> <span class="toc-text">模仿class</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#走进“方法”"><span class="toc-number">1.6.</span> <span class="toc-text">走进“方法”</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#类的构造方法"><span class="toc-number">1.6.1.</span> <span class="toc-text">类的构造方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#静态方法"><span class="toc-number">1.6.2.</span> <span class="toc-text">静态方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#属性方法"><span class="toc-number">1.6.3.</span> <span class="toc-text">属性方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#symbol方法"><span class="toc-number">1.6.4.</span> <span class="toc-text">symbol方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#总结"><span class="toc-number">1.7.</span> <span class="toc-text">总结</span></a></li></ol></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=http://ecmadao.com/Coding-Guide/2017/01/13/Notes/译文/ES6/【译文】用ES6写更赞的JavaScript（2）/"><i class="fa fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=http://ecmadao.com/Coding-Guide/2017/01/13/Notes/译文/ES6/【译文】用ES6写更赞的JavaScript（2）/&text=【译文】用ES6写更赞的JavaScript（2）"><i class="fa fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=http://ecmadao.com/Coding-Guide/2017/01/13/Notes/译文/ES6/【译文】用ES6写更赞的JavaScript（2）/&title=【译文】用ES6写更赞的JavaScript（2）"><i class="fa fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=http://ecmadao.com/Coding-Guide/2017/01/13/Notes/译文/ES6/【译文】用ES6写更赞的JavaScript（2）/&is_video=false&description=【译文】用ES6写更赞的JavaScript（2）"><i class="fa fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=【译文】用ES6写更赞的JavaScript（2）&body=Check out this article: http://ecmadao.com/Coding-Guide/2017/01/13/Notes/译文/ES6/【译文】用ES6写更赞的JavaScript（2）/"><i class="fa fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=http://ecmadao.com/Coding-Guide/2017/01/13/Notes/译文/ES6/【译文】用ES6写更赞的JavaScript（2）/&title=【译文】用ES6写更赞的JavaScript（2）"><i class="fa fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=http://ecmadao.com/Coding-Guide/2017/01/13/Notes/译文/ES6/【译文】用ES6写更赞的JavaScript（2）/&title=【译文】用ES6写更赞的JavaScript（2）"><i class="fa fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=http://ecmadao.com/Coding-Guide/2017/01/13/Notes/译文/ES6/【译文】用ES6写更赞的JavaScript（2）/&title=【译文】用ES6写更赞的JavaScript（2）"><i class="fa fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=http://ecmadao.com/Coding-Guide/2017/01/13/Notes/译文/ES6/【译文】用ES6写更赞的JavaScript（2）/&title=【译文】用ES6写更赞的JavaScript（2）"><i class="fa fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=http://ecmadao.com/Coding-Guide/2017/01/13/Notes/译文/ES6/【译文】用ES6写更赞的JavaScript（2）/&name=【译文】用ES6写更赞的JavaScript（2）&description="><i class="fa fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
      <ul>
        <li id="toc"><a class="icon" href="#" onclick='$("#toc-footer").toggle();return false;'><i class="fa fa-list fa-lg" aria-hidden="true"></i> TOC</a></li>
        <li id="share"><a class="icon" href="#" onclick='$("#share-footer").toggle();return false;'><i class="fa fa-share-alt fa-lg" aria-hidden="true"></i> Share</a></li>
        <li id="top" style="display:none"><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a></li>
        <li id="menu"><a class="icon" href="#" onclick='$("#nav-footer").toggle();return false;'><i class="fa fa-bars fa-lg" aria-hidden="true"></i> Menu</a></li>
      </ul>
    </div>

  </div>
</div>

    
    <footer id="footer">
  <div class="footer-left">
    Copyright &copy; 2017 ecmadao
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
          <li><a href="/Coding-Guide/">Home</a></li>
         
          <li><a href="/Coding-Guide/about/">About</a></li>
         
          <li><a href="/Coding-Guide/archives/">Articles</a></li>
         
          <li><a href="http://github.com/ecmadao">Projects</a></li>
        
      </ul>
    </nav>
  </div>
</footer>

    <script src="/Coding-Guide/lib/justified-gallery/jquery.justifiedGallery.min.js"></script>
<script src="/Coding-Guide/js/main.js"></script>
<!-- Google Analytics -->

    <script type="text/javascript">
        (function(i,s,o,g,r,a,m) {i['GoogleAnalyticsObject']=r;i[r]=i[r]||function() {
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
        ga('create', 'UA-86660611-1', 'auto');
        ga('send', 'pageview');
    </script>

<!-- Disqus Comments -->

    <script type="text/javascript">
        var disqus_shortname = 'ecmadao-blog';

        (function(){
            var dsq = document.createElement('script');
            dsq.type = 'text/javascript';
            dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        }());
    </script>


</body>
</html>
